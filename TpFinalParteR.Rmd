---
title: "TP final estadistica"
author: "Giancarlo Moroni"
date: "2024-11-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Ejercicio 1

```{r}
print(class(c(T,F)))
print(class(c(T,F,1)))
print(class(c(T,F, 1, "1")))
```
Lo que sucede es para guardar en una estructura que tiene que tener mismo valor, intenta castear los elementos del menos generico, en este caso los booleanos, al mas generico que es el character. Entonces en estos casos:
1. c(T,F) como son del mismo tipo, guarda a los valores en una lista del tipo logical.
2. c(T,F,1) en este caso, hay dos clases distintas, numeric y logical, y como logical puede ser casteada a numeric, entonces T es 1 y F es 0 es terminos de numeric.
3. c(T,F, 1, "1")  en este caso character es la clase mas generica para poder castear, entonces T -> 'True', F -> 'False' y el 1 es "1".

#Ejercicio 2

```{r}
print(class(density))
print(class(density(1:500)))
```
Vemos que las clases son distintas, la diferencia radica en que density es una funcion, pero si nosotros llamamos a la funcion con el vector 1:500, lo que estamos haciendo es viendo que clase tiene el resultado de llamar a la funcion density. En este caso el resultado son varios conjuntos de estructuras:

```{r}
str(density(1:500))
```
#Ejericio 3

```{r}
library(sloop)

print(summary(s3_methods_generic("print")))
```
Vemos que el metodo print tiene para despachar 266 clases distintas, pero esto tambien depende realmente de cuantos paquetes tenga instalados en mi version de R, podria suceder que algun compañero de TP corra esta misma celda y le de un valor distinto.

```{r}
metodos_de_density <- methods(class="density")
metodos_de_density_sin_print <- metodos_de_density[metodos_de_density != "print"]
print(length(metodos_de_density_sin_print))
```
Vemos que en este caso tenemos 6 metodos que tiene la clase density.

#Pregunta 4

```{r}
mu <- 1
sigma_sq <- 1
n <- 30
X <- rnorm(n, mean = mu, sd = sqrt(sigma_sq))

mu0 <- 0
alfa <- 0.05
test_t <- t.test(
  X,
  alternative = "two.sided",
  mu = mu0,
  conf.level = 1 - alfa
)
print(unclass(test_t))
```

Al correr la funcion unclass sobre test_t lo que estamos haciendo es justamente remover la clase de esta estructura, por lo cual veremos reflajada la estructura de datos limpia, que vemos que es una lista:

```{r}
print(class(unclass(test_t)))
```
Esto sucede ya que cuando t.test, calcula los estadisticos, los guarda en una lista y luego le asigna la clase h.test, para que tenga un printeo mas declarativo que el que tiene normalmente una lista.

#Ejercicio 10

```{r}
todos_los_subconjuntos_de_5_elementos <- function() {
  elements <- 1:5
  subcojuntos <- list()
  for (k in 0:5) {
    subconjuntos_de_k <- combn(elements, k, simplify = FALSE)
    subcojuntos <- c(subcojuntos, subconjuntos_de_k)
  }
  return(subcojuntos)
}

df <- data.frame(T = numeric(), S = numeric(), Cantidad = numeric(), Probabilidad = numeric())

crear_tabla_observacion_6 <- function(){
  subconjuntos <- todos_los_subconjuntos_de_5_elementos()
  for (t in 0:15){
    subconjuntos_que_suman_t <- c()
    cantidad <- 0
    for (subconjunto in subconjuntos){
      if (sum(subconjunto) == t){
        subset_str <- if (length(sub) > 0) paste(subconjunto, collapse = ", ") else ""
        string_del_subconjunto <- c("{", subset_str,"}")
        subconjuntos_que_suman_t <- c(subconjuntos_que_suman_t, string_del_subconjunto)
        cantidad <- cantidad + 1
      }
    }
    df <- rbind(df, data.frame(T = t, 
                               S = paste(subconjuntos_que_suman_t, collapse = " "), 
                               Cantidad = cantidad, 
                               Probabilidad = cantidad/32))
  }
  return(df)
}
print(crear_tabla_observacion_6())
```

#Pregunta 12

```{r}
particiones <- function(t, n){
  if (n==0) {
    if (t == 0) return(1)
    return(0)
  }
  
  if (t < 0 || t > n*(n+1)/2) return(0)
  return(particiones(t, n-1) + particiones(t-n, n-1))
}

probabilidad <- function(t, n){
  return(particiones(t, n)/(2**n))
}

stopifnot(
  particiones(t=3, n=4) == 2,
  particiones(t=24, n=12) == 67,
  particiones(t=55, n=10) == 1,
  particiones(t=45, n=30) == 1938
)
```

#Pregunta 13

```{r}

# proba puntual 

dTmas <- function(ts, n) {
  res <- vector(mode = "numeric", length = length(ts))
  for (j in seq_along(ts)) {
    res[j] <- probabilidad(ts[j], n) 
  }
  return(res)
}

# acumulada 

pTmas <- function(ts, n) {
  res <- vector(mode = "numeric", length = length(ts))
  for (j in seq_along(ts)) {
    res[j] <- sum(dTmas((0:ts[j]), n))
  }
  return(res)
}

n <- 15
t <- 34
stopifnot(
  dTmas(24, 12) == 67 / 2 ^ 12,
  dTmas(0:10, 4) == c(1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1) / 16,
  sum(dTmas(0:21, 6)) == 1,
  dTmas(0:2, 55) == 2 ^ -55,
  dTmas(t, n) == dTmas(n * (n + 1) / 2 - t, n),
  pTmas(t, n) == 1 - pTmas(n * (n + 1) / 2 - (t + 1), n)
)
```

#Ejercicio 14

```{r}
library(stats)
set.seed(125)
n <- 15
X <- rnorm(n)
theta0 <- 2


estadistico <- function(x){
  signos <- ifelse(x >= 0, 1, -1)
  modx <- abs(x)
  rango <- rank(modx)
  producto <- signos*rango
  return(sum(producto))
}

mi_wilcox_test <- function(x, alternative, mu) {
  alternative <- match.arg(alternative, c("two.sided", "less", "greater"))
  x <- x - mu
  tobs <- estadistico(x)
  tMasObs <- (tobs/2) + n*(n+1)/4
  if (alternative == 'greater'){
    p.value <- 1 - pTmas(tMasObs - 1, length(x)) 
  } else if (alternative == 'two.sided'){
    p.value <- (1 - pTmas(abs(tobs)/2 + (n*(n+1)/4) - 1, length(x)))*2
  } else {
    p.value <- pTmas(tMasObs, length(x)) 
  }
  
  resultado <- list(
    statistic = tMasObs,
    p.value = p.value,
    alternative = alternative
  )
  
  class(resultado) <- "htest"
  return(resultado)
}

R_wilcox <- wilcox.test(X, alternative="two.sided", mu = theta0)
mi_wilcox <- mi_wilcox_test(X, alternative="two.sided", mu = theta0)
print(mi_wilcox$p.value)
print(R_wilcox$p.value)

stopifnot(
  mi_wilcox$statistic == R_wilcox$statistic,
  mi_wilcox$alternative == R_wilcox$alternative,
  class(mi_wilcox) == "htest",
  abs (mi_wilcox$p.value - R_wilcox$p.value) < 1E-6
)

```

```{r}
set.seed(1234)
n <- 15
X <- rnorm(n)
theta0 <- 1
R_wilcox <- wilcox.test(X, alternative="two.sided", mu = theta0)
mi_wilcox <- mi_wilcox_test(X, alternative="two.sided", mu = theta0)
stopifnot(
 mi_wilcox$statistic == R_wilcox$statistic,
 mi_wilcox$p.value == R_wilcox$p.value,
 mi_wilcox$alternative == R_wilcox$alternative,
 class(mi_wilcox) == "htest"
)
```
#Ejercicio 18
Primero vamos a calcular el valor de k* para maximizar la potencia del test. Por lo tanto vamos calcular cual es el cauntil 0.05 de la distribucion de T+. Aprovechandonos que la distribucion es discreta, vamos a ir calculando la P(T+ = t) del final al principio y sumando cada valor de probabilidad.Para  el t que la suma de las probas supere 0,05(t´), NO lo vamos a considerar y nos vamos a quedar con el t anterior  a él osea t´+1. Ese sera el cuantil 0,05 de la distribución. Luego este será el valor de k* que maximice la potencia por el "trade off"  entre el Error de tipo 1 y el error de tipo 2. Es decir mientras mas grande sea el valor del Error I, más chico será el Error II. Como la potencia del test bajo H1 es 1 - P(Error II), mientras mas grande es la P(Error I), mayor será a pontencia del Test bajo H1. 
```{r}
#Calculemos entonces el k*
# Buscar k* desde el valor máximo posible hasta 1

calculo_cuantil  <- function(n,alfa){
  T_max <- n * (n + 1) / 2  # Valor máximo posible de T^+
  suma_prob <- 0  # Suma acumulada de probabilidades
  k <- 1
  iteraciones <- 0 
  for (t in T_max:0) {
    #iteraciones <- iteraciones +  1
    prob_t <- probabilidad(t, n)  # Probabilidad puntual para T^+ = t
    suma_prob <- suma_prob + prob_t  # Acumular la probabilidad
    if (suma_prob > alpha) {
      k <- t + 1  # Guardar el valor k+1
      break
      #iteraciones<- iteraciones -1 
    }
    
  }
  return(k)
}
print(calculo_cuantil(12,0.05))
print(iteraciones)
print(k)
lista<- seq(60,60)#Esto es P(T+ >= 61), asi que esta bien el k
1- pTmas(lista,12)


```

Una vez calculado el k para n = 12 , ahora vamos a realizar los pasos que aparecen en el TP. Comenzamos generando las m muestra de Yi calcualmos el valor de T+(Yi). 

```{r}
calculo_estadisticoT_mas <- function(x){
  signos <- ifelse(x >= 0, 1, 0)
  modx <- abs(x) #No es necesario pq a las negativas no las vamos a considerar
  rango <- rank(modx)
  producto <- signos*rango
  return(sum(producto))
}
m = 10000
set.seed(1984)
n <- 12
theta1 <- 1
sigma_sq <- 1
vector_Ys = c()
vector_Ys <- replicate(m, {
  X <- rnorm(n, mean = theta1, sd = sqrt(sigma_sq))
  calculo_estadisticoT_mas(X)
}) #Esta forma es como un "for", pero en cada indice se guarda un valor del estadistico 
k <- calculo_cuantil(12,0.05)
vector_resultado <- ifelse(vector_Ys >= k, 1, 0) #IMPORTANTE EL IGUAL
potencia_estimada = (1/m) * sum(vector_resultado)

  



```
LA estimación de la potencia del test es de 0.9271. Con lo cual la  
P(Error II) es 1-0.9144 = 0.0866 que es muy baja. Por lo tanto a partir de bootsrapt podemos decir que el test es bastante bueno?


#Ejercicio 19
Primero debemos computar el test t de Student para esta muestra. Bajo H0, nos queda ....(lo hago en el PDF??). Lo primero que hacemos es calcular el valor de k, donde el test debe ser de nivel 0.05
```{r}
k = qt(0.95,11)

```
Por lo tanto el test queda de la siguienta manera:....
Ahora si podemos pasar a calcular la potencia. Las cuentas realizadas estan en el latex(Agregar cuentas de como llegar hasta poder calcular la potencia bajo tita_1)
El cálculo de la potencia termina siendo:
```{r}


```
Luego pasamos a computar el test de signos
El test de signos va a tener una distribucion Bi(n,1/2) bajo H0, ya que si tita = 0, la distribucuion va a ser simetrica y centrada en 0, por lo que la probabilidad de ser mayor o menos que cero es la misma.
Por lo tanto solo nos falta encontrar el k, tq la potencia del test bajo H0 es menor a 0.05
```{r}

calculo_cuantil_binomial  <- function(n,alfa){
  T_max <- n   # Valor máximo posible de T^+
  suma_prob <- 0  # Suma acumulada de probabilidades
  k <- 1
  iteraciones <- 0 
  for (t in T_max:0) {
    prob_t <- dbinom(t, n,0.5)  # Probabilidad puntual para T^+ = t
    suma_prob <- suma_prob + prob_t  # Acumular la probabilidad
    if (suma_prob > alpha) {
      k <- t + 1  # Guardar el valor k+1
      break
    }
    
  }
  return(k)
}

k = calculo_cuantil_binomial(12,0.05)

```
Ahora queda calcular la potencia del test via Bootstrap. 
```{r}

calculo_estadistico_signo <- function(x){
  signos <- ifelse(x >= 0, 1, 0)
  return(sum(signos))
}
m = 10000
set.seed(1984)
n <- 12
theta1 <- 1
sigma_sq <- 1
vector_Ys = c()
vector_Ys <- replicate(m, {
  X <- rnorm(n, mean = theta1, sd = sqrt(sigma_sq))
  calculo_estadistico_signo(X)
}) #Esta forma es como un "for", pero en cada indice se guarda un valor del estadistico 
k <- calculo_cuantil_binomial(12,0.05)
vector_resultado_bin <- ifelse(vector_Ys >= k, 1, 0) #IMPORTANTE EL IGUAL
potencia_estimada_bin = (1/m) * sum(vector_resultado_bin)
```

